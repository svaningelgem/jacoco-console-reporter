package io.github.svaningelgem;

import lombok.var;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.model.Plugin;
import org.apache.maven.model.PluginExecution;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecution;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.codehaus.plexus.util.xml.Xpp3Dom;
import org.jacoco.core.analysis.Analyzer;
import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.IBundleCoverage;
import org.jacoco.core.analysis.IClassCoverage;
import org.jacoco.core.analysis.ICounter;
import org.jacoco.core.analysis.IPackageCoverage;
import org.jacoco.core.analysis.ISourceFileCoverage;
import org.jacoco.core.data.ExecutionDataStore;
import org.jacoco.report.IReportVisitor;
import org.jacoco.report.MultiSourceFileLocator;
import org.jacoco.report.xml.XMLFormatter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Properties;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Generates a console-based coverage report from JaCoCo execution data.
 * This plugin provides a simple way to view coverage metrics directly in the console
 * without needing to generate HTML or XML reports.
 */
@Mojo(name = "report", defaultPhase = LifecyclePhase.VERIFY, threadSafe = true)
public class JacocoConsoleReporterMojo extends AbstractMojo {
    private final Pattern PACKAGE_PATTERN = Pattern.compile("(?:^|\\*/)\\s*package\\s+([^;]+);", Pattern.DOTALL | Pattern.MULTILINE);
    private final String PROPERTY_PREFIX = "jacoco.reporter.";

    /**
     * Defer console reporting until the final module in multi-module builds.
     * When true, accumulates coverage data but only reports at the end.
     */
    @Parameter(defaultValue = "true", property = PROPERTY_PREFIX + "deferReporting")
    boolean deferReporting;

    /**
     * Display individual source files in the coverage tree.
     * When false, shows only package-level aggregation.
     */
    @Parameter(defaultValue = "false", property = PROPERTY_PREFIX + "showFiles")
    boolean showFiles;

    /**
     * Display missing line numbers for each source file.
     * Only applies when showFiles is true.
     */
    @Parameter(defaultValue = "false", property = PROPERTY_PREFIX + "showMissingLines")
    boolean showMissingLines;

    /**
     * Enable the hierarchical tree view in console output.
     * When false, disables all tree display regardless of showFiles setting.
     */
    @Parameter(defaultValue = "true", property = PROPERTY_PREFIX + "showTree")
    boolean showTree;

    /**
     * Include overall coverage summary statistics in the report.
     */
    @Parameter(defaultValue = "true", property = PROPERTY_PREFIX + "showSummary")
    boolean showSummary;

    /**
     * Weight for class coverage in overall score calculation.
     */
    @Parameter(defaultValue = "0.1", property = PROPERTY_PREFIX + "weightClassCoverage")
    double weightClassCoverage;

    /**
     * Weight for method coverage in overall score calculation.
     */
    @Parameter(defaultValue = "0.1", property = PROPERTY_PREFIX + "weightMethodCoverage")
    double weightMethodCoverage;

    /**
     * Weight for branch coverage in overall score calculation.
     */
    @Parameter(defaultValue = "0.4", property = PROPERTY_PREFIX + "weightBranchCoverage")
    double weightBranchCoverage;

    /**
     * Weight for line coverage in overall score calculation.
     */
    @Parameter(defaultValue = "0.4", property = PROPERTY_PREFIX + "weightLineCoverage")
    double weightLineCoverage;

    /**
     * Exclude auto-generated classes from build output directories.
     * Filters out classes typically generated by annotation processors, compilers, etc.
     */
    @Parameter(defaultValue = "true", property = PROPERTY_PREFIX + "ignoreFilesInBuildDirectory")
    boolean ignoreFilesInBuildDirectory;

    /**
     * Apply SonarQube exclusion patterns when analyzing coverage.
     * Reads and honors patterns from sonar-project.properties or pom configuration.
     */
    @Parameter(defaultValue = "true", property = PROPERTY_PREFIX + "interpretSonarIgnorePatterns")
    boolean interpretSonarIgnorePatterns;

    /**
     * Enable XML report generation alongside console output.
     */
    @Parameter(defaultValue = "false", property = PROPERTY_PREFIX + "writeXmlReport")
    boolean writeXmlReport;

    /**
     * Target file path for the generated XML coverage report.
     */
    @Parameter(defaultValue = "${session.executionRootDirectory}/coverage.xml", property = PROPERTY_PREFIX + "xmlOutputFile")
    File xmlOutputFile;

    /**
     * The Maven project.
     */
    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    MavenProject project;

    /**
     * The Maven session.
     */
    @Parameter(defaultValue = "${session}", readonly = true, required = true)
    MavenSession mavenSession;

    /**
     * The execution step
     */
    @Parameter(defaultValue = "${mojoExecution}", readonly = true)
    MojoExecution mojoExecution;

    /**
     * JaCoCo plugin info for dependency discovery
     */
    private static final String JACOCO_GROUP_ID = "org.jacoco";
    private static final String JACOCO_ARTIFACT_ID = "jacoco-maven-plugin";

    static final Set<File> collectedExecFilePaths = new HashSet<>();
    static final Set<File> collectedClassesPaths = new HashSet<>();
    static final Set<Pattern> collectedExcludePatterns = new HashSet<>();
    static final Set<SonarExclusionPattern> collectedSonarExcludePatterns = new HashSet<>();

    File targetDir;
    File baseDir;
    File classesDirectory;

    FileReader fileReader = new FileReader();

    void setupDefaultVariables() {
        targetDir = new File(project.getBuild().getDirectory());
        baseDir = project.getBasedir();
        classesDirectory = new File(project.getBuild().getOutputDirectory()).getAbsoluteFile();
    }

    public void execute() throws MojoExecutionException {
        setupDefaultVariables();

        doSomethingForEachPluginConfiguration(JACOCO_GROUP_ID, JACOCO_ARTIFACT_ID, "destFile", destFile -> {
            File jacocoExecFile = new File(destFile).getAbsoluteFile();
            collectedExecFilePaths.add(jacocoExecFile);
            if (jacocoExecFile.exists()) {
                getLog().debug("Added exec file from current module: " + jacocoExecFile);
            }
        }, project.getBuild().getDirectory() + "/jacoco.exec");

        collectedClassesPaths.add(classesDirectory);
        getLog().debug("Collected Classes: " + collectedClassesPaths);

        loadExclusionPatterns();

        // If we're deferring and this isn't the last module, return
        if (deferReporting && !shouldReport()) {
            getLog().info("Deferring JaCoCo reporting until the end of the build");
            return;
        }

        generateReports();
    }

    /**
     * Loads exclusion patterns from configuration and JaCoCo plugin settings
     */
    void loadExclusionPatterns() {
        addBuildDirExclusion();
        addJacocoExclusions();
        addSonarExclusions();
    }

    /**
     * Adds an exclusion pattern for files in the build directory if configured
     */
    void addBuildDirExclusion() {
        if (!ignoreFilesInBuildDirectory) {
            return;
        }

        try {
            String buildDirPath = fileReader.canonicalPath(targetDir);
            Files.walkFileTree(Paths.get(buildDirPath), new SimpleFileVisitor<Path>() {
                @Override
                public @NotNull FileVisitResult visitFile(@NotNull Path file, @NotNull BasicFileAttributes attrs) {
                    String filePath = file.toString().toLowerCase(Locale.ENGLISH);
                    if (!filePath.endsWith(".java")) {
                        return FileVisitResult.CONTINUE;
                    }

                    String content;
                    try {
                        content = fileReader.readAllBytes(file);
                    } catch (IOException e) {
                        getLog().warn("Failed to read file: " + file, e);
                        return FileVisitResult.CONTINUE;
                    }

                    Matcher matcher = PACKAGE_PATTERN.matcher(content);
                    if (!matcher.find()) {
                        return FileVisitResult.CONTINUE;
                    }

                    String packageName = matcher.group(1).trim();
                    String fileName = file.getFileName().toString();
                    String className = fileName.substring(0, fileName.lastIndexOf('.')) + ".class";

                    // Add to exclusion patterns
                    addExclusion(packageName.replace(".", "/") + "/" + className);

                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            getLog().warn("Failed to add build directory exclusion: " + e.getMessage());
        }
    }

    /**
     * Extracts exclusion patterns from the JaCoCo plugin configuration
     */
    void addJacocoExclusions() {
        doSomethingForEachPluginConfiguration(JACOCO_GROUP_ID, JACOCO_ARTIFACT_ID, "excludes.exclude", excludePattern -> {
            addExclusion(excludePattern);
            getLog().debug("Excluded pattern: " + excludePattern);
        }, null);
    }

    /**
     * Extracts exclusion patterns from Sonar properties
     */
    void addSonarExclusions() {
        if (!interpretSonarIgnorePatterns) return;

        // Check for Sonar exclusions in project properties
        Properties projectProperties = project.getProperties();

        // Handle sonar.exclusions (file-based patterns)
        String sonarExclusions = projectProperties.getProperty("sonar.exclusions");
        if (sonarExclusions != null && !sonarExclusions.trim().isEmpty()) {
            addSonarFileExclusions(sonarExclusions);
        }

        // Handle sonar.coverage.exclusions (file-based patterns)
        String sonarCoverageExclusions = projectProperties.getProperty("sonar.coverage.exclusions");
        if (sonarCoverageExclusions != null && !sonarCoverageExclusions.trim().isEmpty()) {
            addSonarFileExclusions(sonarCoverageExclusions);
        }
    }

    /**
     * Processes Sonar file-based exclusions and stores them for later evaluation
     */
    void addSonarFileExclusions(@NotNull String exclusions) {
        String[] patterns = exclusions.split(",");
        for (String pattern : patterns) {
            pattern = pattern.trim();
            if (pattern.isEmpty()) {
                continue;
            }

            // Store the original pattern with project context for later evaluation
            SonarExclusionPattern sonarPattern = new SonarExclusionPattern(pattern, project);
            collectedSonarExcludePatterns.add(sonarPattern);
            getLog().debug("Added Sonar file exclusion pattern: " + pattern);
        }
    }

    /**
     * Converts a JaCoCo exclude pattern to a Java regex Pattern
     * <p/>
     * Examples:
     * <exclude>com/baeldung/** /ExcludedPOJO.class</exclude>
     * <exclude>com/baeldung/** /*DTO.*</exclude>
     * <exclude>** /config/*</exclude>
     */
    @Nullable Pattern convertExclusionToPattern(@NotNull String jacocoPattern) {
        jacocoPattern = jacocoPattern.replace("\\", "/").trim();

        // Handle the .class extension
        if (jacocoPattern.toLowerCase(Locale.ENGLISH).endsWith(".class")) {
            jacocoPattern = jacocoPattern.substring(0, jacocoPattern.length() - 6).trim();
        }

        if (jacocoPattern.isEmpty()) {
            return null;
        }

        // Use temporary placeholders to avoid interference between replacements
        String regex = jacocoPattern.replace("**/", "__DOUBLE_STAR__") // Any directory
                .replace("**", "__DOUBLE_STAR__") // Any directory
                .replace("*", "__STAR__") // Any character (but not a directory)
                .replace(".", "__DOT__");

        // Now perform the actual replacements
        regex = regex.replace("__DOUBLE_STAR__", "(?:[^/]*/)*").replace("__STAR__", "[^/]*").replace("__DOT__", "\\.");

        regex = "^" + regex + "$";

        getLog().debug("Converted pattern '" + jacocoPattern + "' to regex '" + regex + "'");

        return Pattern.compile(regex);
    }

    void addExclusion(@NotNull String jacocoPattern) {
        for (String pattern : jacocoPattern.split(",")) {
            Pattern converted = convertExclusionToPattern(pattern);
            if (converted != null) {
                collectedExcludePatterns.add(converted);
            }
        }
    }

    /**
     * Checks if a class should be excluded based on its name and file path
     */
    boolean isExcluded(String className) {
        return isExcluded(className, null);
    }

    /**
     * Checks if a class should be excluded based on its name and optional file path
     */
    boolean isExcluded(String className, String filePath) {
        // Check JaCoCo-style package exclusions
        if (!collectedExcludePatterns.isEmpty()) {
            if (collectedExcludePatterns.stream().anyMatch(p -> p.matcher(className).matches())) {
                return true;
            }
        }

        // Check Sonar-style file exclusions if we have a file path
        if (filePath != null && !collectedSonarExcludePatterns.isEmpty()) {
            for (SonarExclusionPattern sonarPattern : collectedSonarExcludePatterns) {
                if (sonarPattern.matches(filePath, project)) {
                    getLog().debug("Excluded by Sonar pattern '" + sonarPattern.getOriginalPattern() + "': " + filePath);
                    return true;
                }
            }
        }

        return false;
    }

    void generateReports() throws MojoExecutionException {
        try {
            getLog().debug("Using exclusion patterns: " + collectedExcludePatterns);

            getLog().debug("Loading execution data");
            ExecutionDataStore executionDataStore = loadExecutionData();

            getLog().debug("Analyzing coverage");
            IBundleCoverage bundle = analyzeCoverage(executionDataStore);

            getLog().debug("Building internal tree model");
            DirectoryNode root = buildDirectoryTree(bundle);

            getLog().debug("Printing reports");
            printCoverageReport(root);
            generateXmlReport(bundle);
        } catch (IOException e) {
            throw new MojoExecutionException("Failed to process JaCoCo data", e);
        }
    }

    /**
     * Determines if this is the last module in a multi-module build
     * --> If so: start reporting
     */
    boolean shouldReport() {
        //Defer execution until the last project.
        return !deferReporting || project.getId().equals(mavenSession.getProjects().get(mavenSession.getProjects().size() - 1).getId());
    }

    Queue<Xpp3Dom> digIntoConfig(Xpp3Dom config, String[] parts) {
        if (config == null || parts == null || parts.length == 0) {
            return null;
        }

        // Queue of nodes to process at the current level
        Queue<Xpp3Dom> currentLevelNodes = new LinkedList<>();
        Queue<Xpp3Dom> nextLevelNodes = null;
        currentLevelNodes.add(config);

        // Process each part of the path
        for (String part : parts) {
            nextLevelNodes = new LinkedList<>();

            // Process all nodes at the current level
            for (Xpp3Dom currentNode : currentLevelNodes) {
                // Get all children with matching name
                Xpp3Dom[] children = currentNode.getChildren(part);
                Collections.addAll(nextLevelNodes, children);
            }

            // If this is the last part in the path, apply consumer to all matching nodes
            if (nextLevelNodes.isEmpty()) {
                // If no matching nodes found at this level, stop processing
                return null;
            }

            // Continue with the next level
            currentLevelNodes = nextLevelNodes;
        }

        return nextLevelNodes;
    }

    Queue<Xpp3Dom> getConfiguration(Plugin plugin, String[] parts) {
        Queue<Xpp3Dom> config = null;

        if (mojoExecution != null) {
            PluginExecution exec = plugin.getExecutionsAsMap().get(mojoExecution.getGoal());
            if (exec != null) {
                config = digIntoConfig((Xpp3Dom) exec.getConfiguration(), parts);
            }
        }

        if (config != null) {
            return config;
        }

        return digIntoConfig((Xpp3Dom) plugin.getConfiguration(), parts);
    }

    void doSomethingForEachPluginConfiguration(String groupId, String artifactId, @NotNull String configValue, Consumer<String> configurationConsumer, String defaultValue) {
        final String[] parts = Arrays.stream(configValue.split("\\.")).filter(s -> !s.isEmpty()).toArray(String[]::new);

        project.getBuildPlugins().stream().filter(plugin -> {
            boolean groupEquals = groupId.equals(plugin.getGroupId());
            boolean artifactEquals = artifactId.equals(plugin.getArtifactId());
            return groupEquals && artifactEquals;
        }).forEach(plugin -> {
            AtomicBoolean foundValue = new AtomicBoolean(false);

            Queue<Xpp3Dom> config = getConfiguration(plugin, parts);
            if (config != null) {
                config.forEach(node -> {
                    String value = node.getValue().trim();
                    if (value.isEmpty()) return;

                    configurationConsumer.accept(value);
                    foundValue.set(true);
                });
            }

            if (!foundValue.get() && defaultValue != null) {
                configurationConsumer.accept(defaultValue);
            }
        });
    }

    /**
     * Loads JaCoCo execution data from the specified files with proper deduplication.
     * Uses the ExecutionDataMerger to ensure line and branch coverage isn't duplicated
     * when aggregating coverage from multiple modules that share common code.
     *
     * @return Populated execution data store with deduplicated coverage information
     * @throws IOException if there are issues reading the JaCoCo execution files
     */
    @NotNull ExecutionDataStore loadExecutionData() throws IOException {
        getLog().debug("Loading execution data with line-level deduplication");
        ExecutionDataMerger merger = new ExecutionDataMerger();

        // Pass all exec files to the merger
        ExecutionDataStore executionDataStore = merger.loadExecutionData(collectedExecFilePaths);

        int fileCount = (int) collectedExecFilePaths.stream().filter(file -> file != null && file.exists()).count();

        getLog().debug(String.format("Processed %d exec files containing data for %d unique classes", fileCount, merger.getUniqueClassCount()));

        return executionDataStore;
    }

    /**
     * Analyzes the compiled classes using the execution data to build coverage information.
     * Uses JaCoCo's analyzer to process all class files in the specified directory,
     * building a complete picture of code coverage. Applies exclusion patterns to filter
     * out classes that should not be included in coverage analysis.
     *
     * @param executionDataStore Contains the execution data from JaCoCo
     * @return A bundle containing all coverage information
     * @throws IOException if there are issues reading the class files
     */
    @NotNull IBundleCoverage analyzeCoverage(@NotNull ExecutionDataStore executionDataStore) throws IOException {
        // Create a custom CoverageBuilder that filters excluded classes
        CoverageBuilder coverageBuilder = new CoverageBuilder();
        Analyzer analyzer = new Analyzer(executionDataStore, coverageBuilder);

        for (File classPath : collectedClassesPaths) {
            if (classPath == null || !classPath.exists()) {
                continue;
            }

            getLog().debug("Analyzing class files in: " + classPath.getAbsolutePath());
            Files.walkFileTree(classPath.toPath(), new SimpleFileVisitor<Path>() {
                @Override
                public @NotNull FileVisitResult visitFile(@NotNull Path file, @NotNull BasicFileAttributes attrs) {
                    String filePath = file.toString().toLowerCase(Locale.ENGLISH);
                    if (filePath.endsWith(".class")) {
                        try (FileInputStream in = new FileInputStream(file.toFile())) {
                            analyzer.analyzeClass(in, file.toString());
                        } catch (Exception e) {
                            getLog().debug("Error analyzing class file: " + file + ": " + e.getMessage());
                        }
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
        }

        return coverageBuilder.getBundle("Project");
    }

    /**
     * Prints the coverage report to the console in a tree-like structure.
     * The report includes coverage metrics for each package and source file.
     *
     * @param root The root node of the directory tree containing coverage information
     */
    void printCoverageReport(@NotNull DirectoryNode root) {
        printTree(root);
        printSummary(root);
    }

    void printSummary(@NotNull DirectoryNode root) {
        if (!showSummary) return;

        CoverageMetrics total = root.getMetrics();

        getLog().info("Overall Coverage Summary");
        getLog().info("------------------------");
        getLog().info("Class coverage : " + Defaults.getInstance().formatCoverage(total.getCoveredClasses(), total.getTotalClasses()));
        getLog().info("Method coverage: " + Defaults.getInstance().formatCoverage(total.getCoveredMethods(), total.getTotalMethods()));
        getLog().info("Branch coverage: " + Defaults.getInstance().formatCoverage(total.getCoveredBranches(), total.getTotalBranches()));
        getLog().info("Line coverage  : " + Defaults.getInstance().formatCoverage(total.getCoveredLines(), total.getTotalLines()));

        double combinedCoverage = 0;
        double combinedTotalCoverage = 0;
        combinedCoverage += total.getCoveredClasses() * weightClassCoverage;
        combinedTotalCoverage += total.getTotalClasses() * weightClassCoverage;
        combinedCoverage += total.getCoveredMethods() * weightMethodCoverage;
        combinedTotalCoverage += total.getTotalMethods() * weightMethodCoverage;
        combinedCoverage += total.getCoveredBranches() * weightBranchCoverage;
        combinedTotalCoverage += total.getTotalBranches() * weightBranchCoverage;
        combinedCoverage += total.getCoveredLines() * weightLineCoverage;
        combinedTotalCoverage += total.getTotalLines() * weightLineCoverage;

        getLog().info(String.format("Combined coverage: %5.2f%% (Class %d%%, Method %d%%, Branch %d%%, Line %d%%)", combinedTotalCoverage == 0 ? 100. : combinedCoverage * 100.0 / combinedTotalCoverage, (int) (weightClassCoverage * 100.0), (int) (weightMethodCoverage * 100.0), (int) (weightBranchCoverage * 100.0), (int) (weightLineCoverage * 100.0)));

    }

    void printTree(@NotNull DirectoryNode root) {
        if (!showTree) return;

        // Print header
        getLog().info("Overall Coverage Summary");
        getLog().info(String.format(Defaults.getInstance().lineFormat, "Package", "Class, %", "Method, %", "Branch, %", "Line, %"));
        getLog().info(Defaults.getInstance().divider);

        // Print the tree structure - start with an empty prefix for root
        root.printTree(getLog(), "", Defaults.getInstance().lineFormat, "", showFiles);

        // Print total metrics
        getLog().info(Defaults.getInstance().divider);
        CoverageMetrics total = root.getMetrics();
        getLog().info(String.format(Defaults.getInstance().lineFormat, "all classes", Defaults.getInstance().formatCoverage(total.getCoveredClasses(), total.getTotalClasses()), Defaults.getInstance().formatCoverage(total.getCoveredMethods(), total.getTotalMethods()), Defaults.getInstance().formatCoverage(total.getCoveredBranches(), total.getTotalBranches()), Defaults.getInstance().formatCoverage(total.getCoveredLines(), total.getTotalLines())));
    }

    /**
     * Formats missing lines into a compact string representation.
     * Groups consecutive lines into ranges (e.g., "3-5") and lists singles (e.g., "7, 9")
     * Also includes partially covered lines with "partial: " prefix
     */
    @NotNull String formatMissingLines(@NotNull ISourceFileCoverage sourceFile) {
        List<Integer> missingLines = new ArrayList<>();
        List<Integer> partialLines = new ArrayList<>();

        // Collect uncovered and partially covered lines
        for (int i = sourceFile.getFirstLine(); i <= sourceFile.getLastLine(); i++) {
            int status = sourceFile.getLine(i).getStatus();
            if (status == ICounter.NOT_COVERED) {
                missingLines.add(i);
            } else if (status == ICounter.PARTLY_COVERED) {
                partialLines.add(i);
            }
        }

        if (missingLines.isEmpty() && partialLines.isEmpty()) {
            return "";
        }

        List<String> result = new ArrayList<>();

        // Group consecutive missing lines into ranges
        if (!missingLines.isEmpty()) {
            List<String> groups = new ArrayList<>();
            int start = missingLines.get(0);
            int end = start;

            for (int i = 1; i < missingLines.size(); i++) {
                int current = missingLines.get(i);
                if (current == end + 1) {
                    end = current;
                } else {
                    // End of a sequence
                    if (start == end) {
                        groups.add(String.valueOf(start));
                    } else {
                        groups.add(start + "-" + end);
                    }
                    start = current;
                    end = current;
                }
            }

            // Add the last group
            if (start == end) {
                groups.add(String.valueOf(start));
            } else {
                groups.add(start + "-" + end);
            }

            result.addAll(groups);
        }

        // Add partial lines (not grouped)
        if (!partialLines.isEmpty()) {
            List<String> partialStrings = partialLines.stream().map(String::valueOf).collect(java.util.stream.Collectors.toList());
            result.add("partial: " + String.join(", ", partialStrings));
        }

        return String.join(", ", result);
    }

    /**
     * Checks if a given source file should be excluded.
     */
    boolean isSourceFileExcluded(@NotNull IPackageCoverage packageCoverage,
                                         @NotNull ISourceFileCoverage sourceFileCoverage) {
        String filename = sourceFileCoverage.getName();
        String className = filename.substring(0, filename.lastIndexOf('.'));
        String packageName = packageCoverage.getName();
        String classPath = packageName + "/" + className;

        // Construct potential file paths for Sonar pattern matching
        String javaFilePath = packageName.replace("\\", "/") + "/" + filename;
        String srcMainJavaPath = "src/main/java/" + javaFilePath;
        String srcTestJavaPath = "src/test/java/" + javaFilePath;

        // Check exclusions with both package-style and file-style paths
        if (isExcluded(classPath) ||
                isExcluded(classPath, javaFilePath) ||
                isExcluded(classPath, srcMainJavaPath) ||
                isExcluded(classPath, srcTestJavaPath)) {
            getLog().debug("Excluded source file: " + javaFilePath);
            return true;
        }
        return false;
    }

    /**
     * Adds a source file to the directory tree unless excluded.
     */
    void buildDirectoryTreeAddNode(DirectoryNode root,
                                   @NotNull IPackageCoverage packageCoverage,
                                   @NotNull ISourceFileCoverage sourceFileCoverage) {
        if (isSourceFileExcluded(packageCoverage, sourceFileCoverage)) {
            return;
        }

        String packageName = packageCoverage.getName();
        String[] pathComponents = packageName.split("/");
        DirectoryNode current = root;
        for (String component : pathComponents) {
            current = current.getSubdirectories().computeIfAbsent(component, DirectoryNode::new);
        }

        String sourceFileName = sourceFileCoverage.getName();
        List<IClassCoverage> classesInFile = new ArrayList<>();
        for (IClassCoverage classCoverage : packageCoverage.getClasses()) {
            if (classCoverage.getSourceFileName().equals(sourceFileName)) {
                classesInFile.add(classCoverage);
            }
        }

        CoverageMetrics metrics = new CoverageMetrics();
        metrics.setTotalClasses(classesInFile.size());
        metrics.setCoveredClasses((int) classesInFile.stream().filter(c -> c.getMethodCounter().getCoveredCount() > 0).count());
        metrics.setTotalMethods(classesInFile.stream().mapToInt(c -> c.getMethodCounter().getTotalCount()).sum());
        metrics.setCoveredMethods(classesInFile.stream().mapToInt(c -> c.getMethodCounter().getCoveredCount()).sum());
        metrics.setTotalLines(sourceFileCoverage.getLineCounter().getTotalCount());
        metrics.setCoveredLines(sourceFileCoverage.getLineCounter().getCoveredCount());
        metrics.setTotalBranches(sourceFileCoverage.getBranchCounter().getTotalCount());
        metrics.setCoveredBranches(sourceFileCoverage.getBranchCounter().getCoveredCount());

        // Extract missing lines if requested
        String missingLines = (showFiles && showMissingLines) ? formatMissingLines(sourceFileCoverage) : null;

        current.getSourceFiles().add(new SourceFileNode(sourceFileName, metrics, missingLines));
    }

    void buildDirectoryTreeAddNode(DirectoryNode root, @NotNull IPackageCoverage packageCoverage) {
        for (ISourceFileCoverage sourceFileCoverage : packageCoverage.getSourceFiles()) {
            buildDirectoryTreeAddNode(root, packageCoverage, sourceFileCoverage);
        }
    }

    void buildDirectoryTreeAddNode(DirectoryNode root, @NotNull IBundleCoverage bundle) {
        for (IPackageCoverage packageCoverage : bundle.getPackages()) {
            buildDirectoryTreeAddNode(root, packageCoverage);
        }
    }

    /**
     * Builds a tree structure representing the package hierarchy and their coverage metrics.
     * Modified to use SourceFileNode instead of SourceFileCoverageData.
     *
     * @param bundle The bundle containing coverage data for all analyzed classes
     * @return The root node of the directory tree containing coverage information
     */
    @NotNull DirectoryNode buildDirectoryTree(@NotNull IBundleCoverage bundle) {
        DirectoryNode root = new DirectoryNode("");
        buildDirectoryTreeAddNode(root, bundle);
        return root;
    }

    void generateXmlReport(@NotNull IBundleCoverage bundle) throws IOException {
        if (xmlOutputFile == null || !writeXmlReport) {
            return;
        }

        getLog().info("Generating aggregated JaCoCo XML report to: " + xmlOutputFile.getAbsolutePath());

        XMLFormatter xmlFormatter = new XMLFormatter();
        try (FileOutputStream output = new FileOutputStream(xmlOutputFile)) {
            IReportVisitor visitor = xmlFormatter.createVisitor(output);

            // Visit the bundle with a MultiSourceFileLocator
            // The XMLFormatter requires session info, but for aggregated reports we can use empty session info
            visitor.visitInfo(Collections.emptyList(), Collections.emptyList());
            visitor.visitBundle(bundle, new MultiSourceFileLocator(4));
            visitor.visitEnd();
        }

        getLog().info("XML report generated successfully.");
    }
}